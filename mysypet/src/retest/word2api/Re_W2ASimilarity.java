package retest.word2api;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Re_W2ASimilarity {

	private static Map<String, Double[]> termVecMap = null;
	private Set<String> apis = null;
	
	/**
	 * Load the vector dictionary into HashMap.
	 * Each key represents a term and each value means the term vector.
	 * The terms have been stemmed by Porter Stemming algorithm.
	 * @param path	dictionary path
	 * @return	a hash map.
	 * @throws IOException
	 */
	public static void loadVecDictionary(String path) throws IOException {
		
		termVecMap = new HashMap<String, Double[]>();
		
		BufferedReader br = new BufferedReader(new FileReader(new File(path)));
		String line = "";
		br.readLine();	// skip the first line. This line is the basic information of the dictionary.
		while (null != (line = br.readLine())) {
			String[] array = line.split(" ");
			String term = array[0];
			String[] values = Arrays.copyOfRange(array, 1, array.length);
			Double[] tmp = new Double[values.length];
			for (int i = 0; i < values.length; ++i) {
				tmp[i] = Double.valueOf(values[i]);
			}
			termVecMap.put(term, tmp);	// put word and its vector into HashMap.
		}
		br.close();
	}
	
	/**
	 * Calculate the similarity between two low-dimensional vectors generated by word2api
	 * @param vec1	the first vector
	 * @param vec2	the second vector
	 * @return	the consin similarity of the two vectors
	 */
	private double getVecSimilairty(Double[] vec1, Double[] vec2) {
		
		double a = 0, b = 0, c = 0;
		for (int i = 0; i < vec1.length; ++i) {
			a += vec1[i] * vec2[i];
			b += vec1[i] * vec1[i];
			c += vec2[i] * vec2[i];
		}
		if (b != 0 && c != 0) {
			return a / (Math.sqrt(b)*Math.sqrt(c));
		} else {
			return 0;
		}
	}
	
	/**
	 * Calculate the similarity between a word and an API
	 * @param word	the word. Word should not be stemmed.
	 * @param api	the API (package_name#method_name).
	 * @return	the similarity between them.
	 */
	public double similarityOfTwoTerms(String word, String api) {
		
		if (termVecMap == null) {
			System.out.println("Please load the vector dictionary first");
			return 0.0;
		}
		
		if (!Tools.checkJavaApi(api)) {
			System.out.println(api+" may not be a Java core API");
			return 0.0;
		}
		
		Double[] vec1 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
		Double[] vec2 = termVecMap.get(api);
		
		if (vec1 == null || vec2 == null) {
			System.out.println(word +" or "+ api +" does not in the dictionary");
			return 0.0;
		}
		
		return this.getVecSimilairty(vec1, vec2);
	}
	
	/**
	 * Calculate the similarity between a set of words and a set of APIs
	 * @param words	the set of words. Terms in this set should not be stemmed.
	 * @param apis	the set of APIs (package_name#method_name)
	 * @param idfMap	the idf value of words and APIs. Terms in idfMap should not be stemmed.
	 * @return
	 */
	public double similarityOfTwoTermSets(Set<String> words, Set<String> apis, Map<String, Double> idfMap) {
		
		// word to API similarity
		Double sumSim1 = 0.0, sumIdf1 = 0.0, sum1 = 0.0;
		for (String word : words) {
			Double[] vec1 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
			Double wordIdf = idfMap.get(word);
			if (vec1 == null || wordIdf == null) {
				continue;
			}
			Double max = 0.0;
			for (String api : apis) {
				if (!Tools.checkJavaApi(api)) {
					continue;
				}
				Double[] vec2 = termVecMap.get(api);
				if (vec2 == null) {
					continue;
				}
				
				Double sim = this.getVecSimilairty(vec1, vec2);
				if (max < sim) {
					max = sim;
				}
			}
			sumSim1 += max * wordIdf;
			sumIdf1 += wordIdf;
		}
		if (sumIdf1 < 0.0001) {
			sum1 = 0.0;
		} else {
			sum1 = sumSim1 / sumIdf1;
		}
		
		// API to word similarity
		Double sumSim2 = 0.0, sumIdf2 = 0.0, sum2 = 0.0;
		for (String api : apis) {
			if (!Tools.checkJavaApi(api)) {
				continue;
			}
			Double[] vec1 = termVecMap.get(api);
			Double apiIdf = idfMap.get(api);
			if (vec1 == null || apiIdf == null) {
				continue;
			}
			Double max = 0.0;
			for (String word : words) {
				Double[] vec2 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
				if (vec2 == null) {
					continue;
				}
				Double sim = this.getVecSimilairty(vec1, vec2);
				if (max < sim) {
					max = sim;
				}
			}
			sumSim2 += max * apiIdf;
			sumIdf2 += apiIdf;
		}
		if (sumIdf2 < 0.0001) {
			sum2 = 0.0;
		} else {
			sum2 = sumSim2 / sumIdf2;
		}
		return (sum1 + sum2) / 2;
	}
		
//	static {
//		String dicPath = "data/java.dic";
//		try {
//			loadVecDictionary(dicPath);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//	}
	
	public static Map<String, Double> getWord2APISimi(String des, Set<String> pkgs) throws NumberFormatException, IOException {
		
		Re_W2ASimilarity w2a = new Re_W2ASimilarity();
		try {
			String dicPath = "data/java.dic";
			w2a.loadVecDictionary(dicPath);
			w2a.getAPIs(pkgs);
		} catch (IOException e) {
			e.printStackTrace();
		}

	/////////////////////////////////////////////////////////////////////////////
		//load df.txt
		String df_path = "data/df.txt";
		Map<String, Double> dfMap = new HashMap<String, Double>();
		BufferedReader df_br = new BufferedReader(new FileReader(new File(df_path)));
		String df_line = "";
		while (null != (df_line = df_br.readLine())) {
			String[] array = df_line.split("\t");
			String term = array[0];
			Double df_value = Double.valueOf(array[1]);
			dfMap.put(term, df_value);
		}
		df_br.close();
		
		
		String query = des;
		String[] token = query.split(" ");
		double word_idf_value = 0.1;
		Set<String> word_query = new HashSet<String>();
		Map<String, Double> idf_Map = new HashMap<String, Double>();
		for(String str : token) {
			if((dfMap.get(new Stemmer().porterStem(str.toLowerCase())))!= null){
			word_query.add(str);
			idf_Map.put(str, 1 / dfMap.get(new Stemmer().porterStem(str.toLowerCase())));//ʹ��df.txt�ļ�
//			System.out.println(str +":"+ 1 / dfMap.get(new Stemmer().porterStem(str.toLowerCase())));//idf
//			System.out.println(str +":"+ dfMap.get(new Stemmer().porterStem(str.toLowerCase())));//df
//			idf_Map.put(str, word_idf_value);//idfȫ������Ϊ0.1
			}
			else continue;
		}	
//		idfMap.put("rectangle", 0.2);
		Map<String, Double> sorted_words_apis = w2a.wordsToAPIs(word_query, idf_Map);	
		return sorted_words_apis;
			
	}
	
/*	
	public static void main(String args[]) throws NumberFormatException, IOException {
		Set<String> pkg = new HashSet<String>();
		pkg.add("java.util.regex");
		getWord2APISimi("Find the matched string with regular expression",pkg);
	}	
*/	
	
	public Map<String, Double> wordsToAPIs(Set<String> word_query, Map<String, Double> idfMap){
		Map<String, Double> apis_sim = new LinkedHashMap<String, Double>();
		double api_idf_value = 0.1;
		for(String api : apis) {
			Set<String> api_one = new HashSet<String>();
			api_one.add(api);
			//����api��idf
			Map<String, Double> new_idfMap = new HashMap<String, Double>();
			new_idfMap.putAll(idfMap);
			new_idfMap.put(api, api_idf_value);	
			//�������ƶ�query--every api
			Double sim = this.similarityOfTwoTermSets(word_query, api_one, new_idfMap);
			apis_sim.put(api, sim);
		}				
		Map<String, Double> sortMap = sortMapByValue(apis_sim);
		return sortMap;
	}
	
	public void getAPIs(Set<String> pkgs){  // get the all apis of the specific packages
/*		Set<String> tempPkgs = new HashSet<String>();
		for(String p : pkgs) {
			char[] ch = p.toCharArray();
			int i = 0;
			for(char c : ch) {
				i++;
				if(Character.isUpperCase(c)) {
					p = p.substring(0, i);
					System.out.println();
					break;
				}
			}
			tempPkgs.add(p);			
		}
*/		
		int cnt = 0;
		apis = new HashSet<String>();
		Set<String> key = termVecMap.keySet();
		Iterator<String> it = key.iterator();
		while(it.hasNext()) {
			String term = it.next();
			if(term.indexOf("#") != -1 && (pkgs.contains(getPkgName(term)) || pkgs.contains(getPkg_ClsName(term)))){
				apis.add(term);
				cnt++;
			}
			else {
				continue;
			}
		}
		System.out.println("---------------------api amount:---------------------"+ cnt);
	}
	
	public static String getPkgName(String api) {
		String pkg_cls = api.split("#")[0];
		int count = pkg_cls.split("\\.").length - 1;
		int pos = getFromIndex(pkg_cls, "\\.", count);
		String package_name = pkg_cls.substring(0, pos);
		return package_name;
	}
	
	public static String getPkg_ClsName(String api) {// for the benchmark.json packages to class level instead of package level
		String pkg_cls = api.split("#")[0];
		
		return pkg_cls;
	}
	
	private static int getFromIndex(String str, String modelStr, Integer count) {
	    Matcher slashMatcher = Pattern.compile(modelStr).matcher(str);
		int index = 0;
	    while(slashMatcher.find()) {
		    index++;
		    if(index == count){
		       break;
		    }
		}
	    return slashMatcher.start();
	}
	
	public static Map<String, Double> sortMapByValue(Map<String, Double> oriMap) {
        if (oriMap == null || oriMap.isEmpty())
            return null;
 
        Map<String, Double> sortedMap = new LinkedHashMap<String, Double>();
        List<Map.Entry<String, Double>> entryList = new ArrayList<Map.Entry<String, Double>>(oriMap.entrySet());
        Collections.sort(entryList, new MapValueComparator());                    //ʹ��MapValueComparator()��map��������               

        //ȡ���н����ǰ100��
//        int count = 2000;
          int count = 300;
        if(entryList.size()>= count){
        	//lists.subList()�÷�
        	for(Map.Entry<String, Double> set : entryList.subList(0, count)){
        		sortedMap.put(set.getKey(), set.getValue());  
        		}
        	}else {
        		for(Map.Entry<String, Double> set : entryList){
        			sortedMap.put(set.getKey(), set.getValue());  
        		}
        	}      	 
//        Iterator<Map.Entry<String, Double>> iter = entryList.iterator();
//        Map.Entry<String, Double> tmpEntry = null;
//        while (iter.hasNext()) {
//            tmpEntry = iter.next();
//            sortedMap.put(tmpEntry.getKey(), tmpEntry.getValue());
//        }
        return sortedMap;
    }
	
/*	//检查是否存在Line2D.Double方法  ---结果是没有
	public static void main(String args[]) throws IOException {
		String dicPath = "data/java.dic";
		Re_W2ASimilarity.loadVecDictionary(dicPath);
		Set<String> apis = new HashSet<String>();
		Set<String> key = termVecMap.keySet();
		Iterator<String> it = key.iterator();
		while(it.hasNext()) {
			String term = it.next();
			if(term.indexOf("#") != -1 && ("java.awt.geom".equals(getPkgName(term)))){
				System.out.println(term);
			}
			else {
				continue;
			}
		}
	}
	*/	
}
